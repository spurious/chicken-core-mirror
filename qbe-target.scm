;;; QBE backend/target for CHICKEN (implementation)
;
; Assumes a 64-bit, little endian target arcitecture


(define output #f)
(define counter 0)
(define switch #f)
(define endswitch #f)
(define lastcase #f)
(define ifstack '())
(define string-counter 0)
(define strings '())

(define (temp #!optional (name "x"))
  (let ((str (conc name counter)))
    (set! counter (add1 counter))
    str))

(define (emit . xs)
  (for-each 
    (lambda (x)
      (case x
        ((#t) (newline output))
        ((#f) #f)
        (else (display x output))))
    xs))

(define (emit-list xs proc)
  (let loop ((xs xs))
    (unless (null? xs)
      (proc (car xs))
      (unless (null? (cdr xs))
        (emit ",")
        (loop (cdr xs))))))

(define (init-target out user-options source-file)
  (set! output out))

(define (finalize-target) #f)

(define (generate-target-code form)
  (when (memq 'y debugging-chicken)
    (flush-output)
    (pp form))
  (statement form))

(define (statement form)
  (case (and (pair? x) (car x))
    ((call tailcall)
     (let ((f (if (and (pair? (cadr x)) (eq? '$ (caadr x)))
                  (conc "$" (cadr x))
                  (expression (cadr x)))))
       (emit #t "call %" f "(")
       (unless (null? args)
         (let loop ((args (cddr x)))
           (let ((a (expression (car args))))
             (emit "l %" a)
             (unless (null? (cdr args))
               (emit ",")
               (loop (cdr args))))))
       (emit ")")))
    ((case)
     (let ((lbl (temp "l"))
           (c (temp "c"))
           (x (expression (cadr x)))
           (yes (temp "yes"))
           (no (temp "no")))
       (when lastcase 
         (emit #t "jmp @" endswitch
               #t "@" lastcase))
       (emit #t "%" c " =w ceql %" x ",%" switch
             #t "jnz %" c ",@" yes ",@" no
             #t "@" yes)
       (set! lastcase no)))
    ((comment) 
     (for-each (cut emit #t <>) (string-split (cadr x) "\n")))
    ((declare)
     #f)
    ((define)
     (let ((export "export "))
       (let loop ((x (cdr x)))
         (case (car x)
           ((extern noreturn) (loop (cdr x)))
           ((static)
            (set! export "")
            (loop (cdr x)))
           (else
             (emit #t export "function ")
             (unless (eq? 'void (car x))
               (emit "l "))
             (emit "$" (cadr x) "(")
             (unless (null? (cddr x))
               (let loop ((args (cddr x)))
                 (emit "l %" (cadar args))
                 (unless (null? (cdr args))
                   (emit ",")
                   (loop (cdr args)))))
             (emit "){" #t "@start")
             (set! counter 0)
             (set! ifstack '())
             (set! lastcase #f)
             (set! switch #f))))))   
    ((end)
     (assert (null? ifstack))
     (emit "}"))
    ((define/array)
     (let ((export "export "))
       (let loop ((x (cdr x)))
         (case (car x)
           ((static) 
            (set! export "")
            (loop (cdr x)))
           ((aligned) (loop (cdr x)))
           (else
             (emit #t export "data $" (caddr x) "={")
             (cond ((null? (caddr x))
                    (emit "z " (type-size (car x))))
                   (else
                    (for-each
                      (lambda (fields) 
                        (data-fields fields (car x)))
                      (cdddr x))))
             (emit "}"))))))
    ((define/variable)
     (let ((export "export "))
       (when (eq? (cadr x) 'static)
         (set! export "")
         (set! x (cdr x)))
       (emit #t export "data $" (caddr x) "={")
       (if (null? (cdddr x))
           (emit "z " (type-size (cadr x)))
           (emit (type-code (cadr x)) " " (cadddr x)))
       (emit "}")))
    ((goto)
     (emit #t "jmp @" (cadr x)))
    ((if)
     (let ((c (expression (cadr x)))
           (tmp (temp "c"))
           (yes (temp "if"))
           (no (temp "else")))
       (emit #t "%" tmp " =w cnel 6,%" c
             #t "jnz %" tmp ",@" yes ",@" no
             #t "@" yes)
       (set! ifstack (cons no ifstack))))
    ((else)
     (assert (pair? ifstack))
     (let ((end (temp "endif")))
       (emit #t "jmp @" end
             #t "@" (car ifstack))
       (set-car! ifstack end)))
    ((endif)
     (assert (pair? ifstack))
     (emit #t "@" (car ifstack))
     (set! ifstack (cdr ifstack)))
    ((inline)
     (emit #t (cadr x)))
    ((label)
     (emit #t "@" (cadr x)))
    ((let let/ptr)
     (unless (null? (cddr x))
       (let ((x (expression (caddr x))))
         (emit #t "%" (cadr x) " =l %" x))))
    ((let/proc)
     (let ((x (expression (caddr x))))
       (emit #t "%" (cadr x) " =l %" x)))
    ((let/array)
     (let ((x (expression (caddr x))))
       (emit #t "%" (cadr x) " =l alloc8 " (caddr x))))
    ((let/unboxed)
     (unless (null? (cdddr x))
       (let ((x (expression (cadddr x))))
         (emit #t "%" (cadr x) " =" (type-code (cadr x)) " %" x))))
    ((stack_overflow_check)
     (intrinsic '(stack_overflow_check)))
    ((main_entry_point)
     (intrinsic '(main_entry_point)))
    ((return)
     (let ((x (expression (cadr x))))
       (emit #t "ret %" x)))
    ((set)
     (let ((x (expression (caddr x))))
       (emit #t "%" (cadr x) " =l %" x)))
    ((switch)
     (set! endswitch (temp "endswitch"))
     (set! lastcase #f)
     (set! switch (temp "switch")))
    ((default)
     (when lastcase
       (emit #t "jmp @" endswitch)
       (emit #t "@" lastcase)))
    ((endswitch)
     (emit #t "@" endswitch))
    (else (bomb "target - bad statement" x))))

(define (expression x)
  (let ((r (temp)))
    (cond ((symbol? x) 
           (emit #t "%" r " =l %" x)
           r)
          ((atom? x) 
           (emit #t "%" r " =l " x))
          (else
            (case (and (pair? x) (car x))
              (($) 
               (emit #t "%" r " =l $" (cadr x)))
              ((begin)
               (let loop ((x (cdr x)))
                 (let ((r (expression (car x))))
                   (if (null? (cdr x))
                       r
                       (loop (cdr x))))))
              ((adr) (lvalue (cadr x)))
              ((box)
               (let* ((aexp (expression (cadr x)))
                      (val (expression (caddr x)))
                      (aexp2 (temp))
                      (aexp3 (temp)))
                 XXX wrong
                 (emit #t "storel "
                       (bitwise-ior (foreign-value "C_VECTOR_TYPE" int)
                                    1)
                       ",%" aexp
                       #t "%" r " =l copy %" aexp
                       #t "%" aexp2 " =l add %" aexp ",8"
                       #t "storel %" val ",%" aexp2
                       #t "%" aexp3 " =l add %" aexp2 ",8")
                 r))
              ((cast) (expression (caddr x)))
              ((call)
               (let ((args (map expression (cddr x))))
                 (if (and (pair? (cadr x)) (eq? '$ (caadr x)))
                     (emit #t "%" r " =l call $" (cadadr x) "(")
                           (let ((proc (expression (cadr x))))
                             (emit #t "%" r " =l call %" proc "(")))
                 (emit-list args (cut emit "%" arg))
                 (emit ")")))
               ((string)
                (emit #t "%" r " =l $" (push-string x)))
               ((closure)
                (let ((size (cadr x))
                      (aexp (expression (caddr x)))
                      (aexp2 (temp))
                      (args (map expression (cdddr x))))
                 XXX wrong
                  (emit #t "storel " 
                        (bitwise-ior (foreign-value "C_CLOSURE_TYPE" int)
                                     size)
                        ",%" aexp
                        #t "%" r " =l copy %" aexp
                        #t "%" aexp2 " =l add %" aexp ",8")
                  (let loop ((args args) (aexp aexp2))
                    (cond ((null? args)
                           (
                      (emit #t "storel %" (car args) ",%" aexp)
                      (loop (cdr args) (temp))
               (for-each
                 (lambda (arg i)
                   (expr aexp)
                   (emit "[" i "]=")
                   (expr arg)
                   (emit ","))
                 (cdddr x) 
                 (list-tabulate size add1))
               (emit "tmp=(C_word)")
               (expr aexp)
               (emit ",")
               (expr aexp)
               (emit "+=" (add1 size) ",tmp)")))
                (
    
(define (type-size type)
  (case type
    ((C_DEBUG_INFO) 24)
    ((C_PTABLE_ENTRY) 16)
    ((char) 1)
    ((int) 4)
    ((word) 8)
    (else (bomb "target - unimplemented type size" type))))
    
(define (type-code type)
  (case type
    ((word long) "l")
    ((int) "w")
    ((short) "h")
    ((char) "b")
    ((float) "s")
    ((double) "d")
    (else (bomb "target - unimplemented type code" type))))

(define (data-fields val type)
  (cond ((vector? val)
         (emit #t)
         (emit-list (vector->list val) data-fields)
         (emit ","))
        ((and (pair? val) (eq? 'C_lihdr (car val)))
         (let ((b1 (cadr val))
               (b2 (caddr val))
               (b3 (cadddr val)))
           (emit #t "b " b3 " " b2 " " b1 ",z 4,b "
                 (foreign-value "C_LAMBDA_INFO_TYPE >> 56" int))))
        (else (emit val ","))))
     
(define (push-string str)
  (let ((name (conc "str" string-counter)))
    (set! string-counter (add1 string-counter))
    (set! strings (alist-cons name str strings))
    name))
                